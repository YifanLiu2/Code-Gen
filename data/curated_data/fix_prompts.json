{
    "HumanEval/0": {
        "Usage": ">>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
        "Clarification": "1. Two numbers are considered close if the absolute difference between them is less than the given threshold.",
        "Self Reflection": ""
    },
    "HumanEval/1": {
        "Usage": ">>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
        "Clarification": "1. There could be multiple groups of valid nested parentheses. A valid nested parentheses means every opening parenthesis has a corresponding closing parenthesis after it and is not nested within other.\n2.Spaces in the input string are ignored.",
        "Self Reflection": ""
    },
    "HumanEval/2": {
        "Usage": ">>> truncate_number(3.5)\n    0.5",
        "Self Reflection": ""
    },
    "HumanEval/3": {
        "Usage": ">>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
        "Clarification": "1. The bank account start with zero balance and each number in the list represent either deposit (positive) or withdraw (negative).\n2. The function return True if at any point the balance is below zero.",
        "Self Reflection": ""
    },
    "HumanEval/4": {
        "Usage": ">>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
        "Clarification": "1. Compute the average absolute difference from the mean for each element in the list.",
        "Additional Information": "1. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case).",
        "Self Reflection": ""
    },
    "HumanEval/5": {
        "Usage": ">>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]",
        "Clarification": "1. Intersperse means insert a number 'delimeter' between every two consecutive elements.",
        "Self Reflection": ""
    },
    "HumanEval/6": {
        "Usage": ">>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]",
        "Clarification": "1. Depth means the deepest level of nesting of parentheses.",
        "Self Reflection": ""
    },
    "HumanEval/7": {
        "Usage": ">>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']",
        "Clarification": "1. By filter, we mean select the strings that contain the given substring.",
        "Self Reflection": ""
    },
    "HumanEval/8": {
        "Usage": ">>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)",
        "Clarification": "1. The sum and product refer to those of all of the element in the given list.\n2. The return should be a tuple in the order of sum and the tuple.",
        "Self Reflection": ""
    },
    "HumanEval/9": {
        "Usage": ">>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]",
        "Clarification": "1. In the returned list, each element at index i is the maximum value from the start of the input list up to index i.",
        "Self Reflection": ""
    },
    "HumanEval/10": {
        "Usage": ">>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'",
        "Additional Information": "1. The palindrome should start with the provided string.",
        "Self Reflection": "",
        "Hint": "Iterate through the string to find the shortest suffix that, when reversed, forms a palindrome with the original string."
    },
    "HumanEval/11": {
        "Usage": ">>> string_xor('010', '110')\n    '100'",
        "Clarification": "1. The binary strings contain only 1s and 0s.",
        "Self Reflection": ""
    },
    "HumanEval/12": {
        "Usage": ">>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'",
        "Clarification": "1. Return the first longest one in a tie. 2. It return None in case of empty string.",
        "Self Reflection": ""
    },
    "HumanEval/13": {
        "Usage": ">>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5",
        "Clarification": "1. The GCD is the largest positive integer that divides both numbers without leaving a remainder.",
        "Self Reflection": ""
    },
    "HumanEval/14": {
        "Usage": ">>> all_prefixes('abc')\n    ['a', 'ab', 'abc']",
        "Clarification": "1. A prefix is defined as any initial segment of the string, starting from the first character and extending up to any point within the string.\n2. Return the list of prefix in order, starting from shortest.",
        "Self Reflection": ""
    },
    "HumanEval/15": {
        "Usage": ">>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'",
        "Clarification": "1. starting from 0 up to n inclusive.\n2. each number seperate by a single white space.",
        "Additional Information": "1. starting from 0 up to n inclusive.\n2. each number seperate by a single white space.",
        "Self Reflection": ""
    },
    "HumanEval/16": {
        "Usage": ">>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4",
        "Clarification": "1. each unique character only count once.",
        "Additional Information": "1. we treat uppercase and lowercase letters as the same character",
        "Self Reflection": ""
    },
    "HumanEval/17": {
        "Usage": ">>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]",
        "Clarification": "1. whole note lasts four beat. Your task is to return a least of number of beat.",
        "Additional Information": "Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]",
        "Self Reflection": ""
    },
    "HumanEval/18": {
        "Usage": ">>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')",
        "Clarification": "1. we include the overlapping occurrences.",
        "Self Reflection": ""
    },
    "HumanEval/19": {
        "Usage": ">>> sort_numbers('three one five')\n    'one three five'",
        "Clarification": "1. assume input is a space-delimited string of numberals from 'zero' to 'nine'.",
        "Additional Information": "1. input is a space-delimited string of numberals from 'zero' to 'nine'.\n2. sort in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/20": {
        "Usage": ">>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)",
        "Clarification": "1. We want to find two closet number in value.\n2. We assume the input list is at least two elements.",
        "Additional Information": "1. The returned is two numbers in a tuple in ascending otder.",
        "Self Reflection": ""
    },
    "HumanEval/21": {
        "Usage": ">>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]",
        "Clarification": "1. By rescale, we mean linearly transform.",
        "Additional Information": "1. We want to linearly transform every elements in a list to the 0 to 1 scale.",
        "Self Reflection": ""
    },
    "HumanEval/22": {
        "Usage": ">>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]",
        "Self Reflection": ""
    },
    "HumanEval/23": {
        "Usage": ">>> strlen('')\n    0\n    >>> strlen('abc')\n    3",
        "Self Reflection": ""
    },
    "HumanEval/24": {
        "Usage": ">>> largest_divisor(15)\n    5",
        "Clarification": "1. We do not consider n itself as the divisor.",
        "Additional Information": "1. By divisor, we mean the largest divisor smaller than n.",
        "Self Reflection": ""
    },
    "HumanEval/25": {
        "Usage": ">>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]",
        "Clarification": "1. Each prime factor appears in the list as many times as it is present in the factorization of 'n.'",
        "Additional Information": "1. The return list should in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/26": {
        "Usage": ">>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]",
        "Clarification": "1. All occurrences of the duplicate integer will be removed.\n2. Keep the original order.",
        "Self Reflection": ""
    },
    "HumanEval/27": {
        "Usage": ">>> flip_case('Hello')\n    'hELLO'",
        "Clarification": "1. By flip, we mean flip lowercase characters to uppercase and uppercase to lowercase.",
        "Self Reflection": ""
    },
    "HumanEval/28": {
        "Usage": ">>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'",
        "Self Reflection": ""
    },
    "HumanEval/29": {
        "Usage": ">>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']",
        "Clarification": "1. By finding the string with the prefix, we mean the string starting with the provided prefix.",
        "Self Reflection": ""
    },
    "HumanEval/30": {
        "Usage": ">>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]",
        "Self Reflection": ""
    },
    "HumanEval/31": {
        "Usage": ">>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False",
        "Self Reflection": ""
    },
    "HumanEval/32": {
        "Usage": ">>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0",
        "Clarification": "1. By solution, we mean find a zero of a polynomial.\n2. The function assumes that 'xs' has an even number of coefficients and that the highest non-zero coefficient guarantees a real solution. It returns a single root of the polynomial where the polynomial evaluates to zero.",
        "Additional Information": "1. The coefficients are ordered from the constant term to the highest degree term.",
        "Self Reflection": ""
    },
    "HumanEval/33": {
        "Usage": ">>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]",
        "Clarification": "1. The index is 0-based index.\n2. The indices that are not divisible by three remain unchanged position in the returned list.",
        "Additional Information": "1. The index is 0-based index.\n2. The indices that are not divisible by three remain unchanged position in the returned list.\n3. Sort in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/34": {
        "Usage": ">>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]",
        "Clarification": "1. The function eliminates duplicates while retaining one instance of each duplicate.",
        "Additional Information": "1. The function eliminates duplicates while retaining one instance of each duplicate.\n2. Sort in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/35": {
        "Usage": ">>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123",
        "Self Reflection": ""
    },
    "HumanEval/36": {
        "Usage": ">>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3",
        "Self Reflection": ""
    },
    "HumanEval/37": {
        "Usage": ">>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]",
        "Clarification": "1. Keep the elements at odd indices unchanged in the returned list.",
        "Additional Information": "1. Keep the elements at odd indices unchanged in the returned list.\n2. Sort the even indices in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/38": {
        "Usage": ">>> decode_cyclic(\"bcaefd\") 'abcdef' >>> decode_cyclic(\"abcdefghijk\") 'bcaefdhgijk'",
        "Clarification": "1. In encoding function, it splits the string into groups of three characters and cyclically shifts each group by moving the first character to the end, unless the group has fewer than three characters. Now we need to decode the string by return it to the original form.",
        "Additional Information": "1. In encoding function, it splits the string into groups of three characters and cyclically shifts each group by moving the first character to the end, unless the group has fewer than three characters. Now we need to decode the string by return it to the original form.",
        "Self Reflection": ""
    },
    "HumanEval/39": {
        "Usage": ">>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3).",
        "Clarification": "1. Among all numbers that are both prime and fib number, we want to find the n-th.",
        "Self Reflection": "",
        "Hint": "Iterate through the Fibonacci sequence while counting how many of the Fibonacci numbers are prime, and stop once you've counted to n. Ensure the starting point to check is fib1 = 0 and fib2 = 1."
    },
    "HumanEval/40": {
        "Usage": " >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False",
        "Clarification": "1. Each element should only be used once.\n2. Return False if the list has less than 3 numbers.",
        "Self Reflection": ""
    },
    "HumanEval/41": {
        "Usage": ">>> car_race_collision(1)\n    1\n    >>> car_race_collision(2)\n    4",
        "Clarification": "1. The two sets of cars start out being very far from each other.\n2. All cars move in the same speed.\n3. Two cars are said to collide  when a car that's moving left to right hits a car that's moving right to left.\n4. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.",
        "Additional Information": "1. n cars are driving left to right;  simultaneously, a different set of n cars are driving right to left. There are 2n cars in total.\n2. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left.",
        "Self Reflection": ""
    },
    "HumanEval/42": {
        "Usage": ">>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]",
        "Self Reflection": ""
    },
    "HumanEval/43": {
        "Usage": ">>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False",
        "Self Reflection": ""
    },
    "HumanEval/44": {
        "Usage": ">>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'",
        "Clarification": "1. return should be in string format, which convert directly from resulting number in new base to string.\n2. the original representation is in base of 10. Convert it to 'base' base.",
        "Self Reflection": ""
    },
    "HumanEval/45": {
        "Usage": ">>> triangle_area(5, 3)\n    7.5",
        "Self Reflection": ""
    },
    "HumanEval/46": {
        "Usage": ">>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14",
        "Clarification": "1. It is 0-indexing, which means the first element has a index of 0 (i.e., Fib4(0) = 0.",
        "Additional Information": "1.  fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).",
        "Self Reflection": ""
    },
    "HumanEval/47": {
        "Usage": ">>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0",
        "Self Reflection": ""
    },
    "HumanEval/48": {
        "Usage": ">>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False",
        "Self Reflection": ""
    },
    "HumanEval/49": {
        "Usage": ">>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)",
        "Self Reflection": ""
    },
    "HumanEval/50": {
        "Usage": ">>> decode_shift('btwqi')\n    'world",
        "Clarification": "1. By shift back, we mean shifts each character by 5 positions in the alphabet order, wrapping around if neccesary.\n2.",
        "Additional Information": "1. The encode_shift function encoded string by shifting every character by 5 in the alphabet. The decoding method take a encoded string and reverse back to the original string.",
        "Self Reflection": ""
    },
    "HumanEval/51": {
        "Usage": ">>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')",
        "Clarification": "1. We take both upper and lower case into account.",
        "Self Reflection": ""
    },
    "HumanEval/52": {
        "Usage": ">>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False",
        "Self Reflection": ""
    },
    "HumanEval/53": {
        "Usage": ">>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12",
        "Self Reflection": ""
    },
    "HumanEval/54": {
        "Usage": ">>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False",
        "Clarification": "1. We only consider the character sets for two strings are same, regardless of the order or frequency of those characters.",
        "Self Reflection": ""
    },
    "HumanEval/55": {
        "Usage": ">>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21",
        "Clarification": "1. We use 0-index, which means fib sequence is defined by Fib(0) = 0 and Fib(1) = 1.",
        "Self Reflection": ""
    },
    "HumanEval/56": {
        "Usage": ">>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False",
        "Clarification": "1. By proper, we mean Each '<' must have a corresponding '>' that follows it. The function allows for nested bracketing and returns True if all opening brackets are correctly closed in the order they appear.",
        "Self Reflection": ""
    },
    "HumanEval/57": {
        "Usage": ">>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True",
        "Clarification": "1. We want to check whether the list is monotone (i.e., non-increasing or non-decreasing).",
        "Self Reflection": ""
    },
    "HumanEval/58": {
        "Usage": ">>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]",
        "Clarification": "1. The returned list should only contain unique element.",
        "Additional Information": "1. The returned list should only contain unique element, in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/59": {
        "Usage": ">>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)",
        "Self Reflection": ""
    },
    "HumanEval/60": {
        "Usage": ">>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)",
        "Clarification": "1. We sum from 1 to n, inclusive.",
        "Self Reflection": ""
    },
    "HumanEval/61": {
        "Usage": ">>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False",
        "Clarification": "1. By proper, we mean each opening bracket '(' must follow by a corresponding closing bracket ')' and no opening bracket can be closed before any of its nested brackets are closed.",
        "Self Reflection": ""
    },
    "HumanEval/62": {
        "Usage": ">>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]",
        "Clarification": "1. xs[i] is the coefficient of the x^i term.\n2.  returns a new list of coefficients representing the derivative of the polynomial.",
        "Additional Information": "1. The input list 'xs' contains the coefficients of the polynomial, where xs[i] is the coefficient of the x^i term.\n2.  returns a new list of coefficients representing the derivative of the polynomial.",
        "Self Reflection": ""
    },
    "HumanEval/63": {
        "Usage": " >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24",
        "Clarification": "1. The sequence is 0-indexed, which means  fibfib(0) = 0\n    - fibfib(1) = 0\n    - fibfib(2) = 1.",
        "Additional Information": "1. The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).",
        "Self Reflection": ""
    },
    "HumanEval/64": {
        "Usage": ">>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3",
        "Clarification": " The vowels considered are 'a', 'e', 'i', 'o', 'u', and 'y' (where 'y' is counted only if it is the last character of the string).",
        "Self Reflection": ""
    },
    "HumanEval/65": {
        "Usage": ">>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"",
        "Additional Information": "If the shift value exceeds the number of digits in x, the digits are reversed.",
        "Self Reflection": ""
    },
    "HumanEval/66": {
        "Usage": "Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153",
        "Clarification": "1. By value, we mean ASCII values.",
        "Self Reflection": ""
    },
    "HumanEval/67": {
        "Usage": "for examble:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19",
        "Clarification": "1.  The string format is 'X apples and Y oranges', where X and Y are integers.",
        "Self Reflection": ""
    },
    "HumanEval/68": {
        "Usage": " Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.",
        "Clarification": "1. If there are multiple nodes with the same smallest even value, the node with the smallest index is returned. If the array is empty or contains no even values, an empty list is returned.",
        "Additional Information": "1. The plucked node should be returned in a list, [ smalest_value, its index ]\n2. If there are multiple nodes with the same smallest even value, the node with the smallest index is returned. If the array is empty or contains no even values, an empty list is returned.",
        "Self Reflection": ""
    },
    "HumanEval/69": {
        "Usage": "Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1",
        "Clarification": "1. By as frequent as itself, we mean its frequency is greater than or equals to its own value.\n2. If no such integer exists, the function returns -1.",
        "Self Reflection": ""
    },
    "HumanEval/70": {
        "Usage": "Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []",
        "Clarification": "1. The order can be explained by: the first element is the minimum value, followed by the maximum value of the remaining elements, then the minimum of the remaining, and so on until all elements are used.",
        "Self Reflection": ""
    },
    "HumanEval/71": {
        "Usage": "Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1",
        "Clarification": "1. We make calculation based on the provided three side length of the triangle.",
        "Additional Information": "1. round results to two decimal.\n2. return -1 if triangle not valid.",
        "Self Reflection": ""
    },
    "HumanEval/72": {
        "Usage": "Example:\n    will_it_fly([1, 2], 5) \u279e False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u279e False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u279e True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u279e True\n    # 3 is less than the maximum possible weight, and it's balanced.",
        "Clarification": "1. By balanced, we mean the list  must be palindromic.\n2. By light enough, we mean the sum is lower than 'w'.",
        "Additional Information": "A list of integers 'q' will 'fly' based on two conditions:\n    1. The list 'q' must be palindromic, meaning it reads the same forwards and backwards.\n    2. The sum of the elements in 'q' must be less than or equal to the maximum allowable weight 'w'.",
        "Self Reflection": ""
    },
    "HumanEval/73": {
        "Usage": "For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0",
        "Clarification": "1. By swap elements, we mean  to replace any one element with another integer.",
        "Self Reflection": ""
    },
    "HumanEval/74": {
        "Usage": "Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']",
        "Clarification": "1.Return the first list for a tie.",
        "Self Reflection": ""
    },
    "HumanEval/75": {
        "Usage": "Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5",
        "Clarification": "1. The three prime could be same (not neccesarily to be distinct).",
        "Self Reflection": ""
    },
    "HumanEval/76": {
        "Usage": "For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false",
        "Clarification": "1. Specifically, we mean if there exists an integer k such that n**k equals x.",
        "Additional Information": "1. By simple power of n, we mean if there exists an integer k such that n**k equals x.",
        "Self Reflection": ""
    },
    "HumanEval/77": {
        "Usage": "Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False",
        "Self Reflection": ""
    },
    "HumanEval/78": {
        "Usage": "Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.",
        "Clarification": "1. Prime digits in hexadecimal are 2, 3, 5, 7, B (11 in decimal), and D (13 in decimal).",
        "Additional Information": "The number string is a hexdecimal number string.",
        "Self Reflection": ""
    },
    "HumanEval/79": {
        "Usage": "Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db",
        "Additional Information": "1. The output binary string is prefixed and suffixed with 'db'.",
        "Self Reflection": ""
    },
    "HumanEval/80": {
        "Usage": "For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False",
        "Clarification": "1. If the string has smaller than 3 characters, return False.",
        "Additional Information": "1. happy is defined as if it has a length of at least 3 and every set of three consecutive characters within the string are distinct.",
        "Self Reflection": ""
    },
    "HumanEval/81": {
        "Usage": "Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']",
        "Additional Information": "- 4.0: A+\n        - > 3.7: A\n        - > 3.3: A-\n        - > 3.0: B+\n        - > 2.7: B\n        - > 2.3: B-\n        - > 2.0: C+\n        - > 1.7: C\n        - > 1.3: C-\n        - > 1.0: D+\n        - > 0.7: D\n        - > 0.0: D-\n        - 0.0: E\n",
        "Self Reflection": ""
    },
    "HumanEval/82": {
        "Usage": "Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False",
        "Self Reflection": ""
    },
    "HumanEval/83": {
        "Usage": ">>> starts_one_ends(2) = 18",
        "Clarification": "1. We only consider n-digit positive integers.\n2. By start/end with 1, we consider positive integers that start or end with 1.",
        "Self Reflection": ""
    },
    "HumanEval/84": {
        "Usage": "Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number",
        "Clarification": "1. By sum of a integer, we mean sum of its digit.",
        "Self Reflection": ""
    },
    "HumanEval/85": {
        "Usage": "Examples:\n        add([4, 2, 6, 7]) ==> 2",
        "Self Reflection": ""
    },
    "HumanEval/86": {
        "Usage": "By sort the characters, we mean sort the characters by its ASCII value in ascending order.",
        "Clarification": "1. By sort characters, we mean by sorting their ASCII value.",
        "Additional Information": "1. By sort characters, we mean by sorting their ASCII value.\n2. We sort in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/87": {
        "Usage": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]",
        "Clarification": "1. There could be multiple occurrences for the given integer.\n2. Each tuple in the format (row index, column index).\n3. By sort the result, we mean row index in ascending order, and within the same row, by column index in descending order.",
        "Additional Information": "1. Each tuple in the format (row index, column index).\n2. By sort the result, we mean row index in ascending order, and within the same row, by column index in descending order.",
        "Self Reflection": ""
    },
    "HumanEval/88": {
        "Usage": "Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]",
        "Self Reflection": ""
    },
    "HumanEval/89": {
        "Usage": "For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'",
        "Clarification": "1. By rotate four places, we mean shift each letter by four places in the alphabet and wrap around if neccesary.",
        "Additional Information": "1. By roate, we mean shift each letter by four places in the alphabet and wrap around if neccesary.",
        "Self Reflection": ""
    },
    "HumanEval/90": {
        "Usage": "next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None",
        "Clarification": "1. By next smallest, we mean second smallest.\n2. If the list has fewer than two unique elements, the function returns None.",
        "Self Reflection": ""
    },
    "HumanEval/91": {
        "Usage": ">>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1",
        "Clarification": "1. Sentences are delimited by '.', '?', or '!'.",
        "Self Reflection": ""
    },
    "HumanEval/92": {
        "Usage": "Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False",
        "Self Reflection": ""
    },
    "HumanEval/93": {
        "Usage": "Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'",
        "Clarification": "1. By changing letter case, we mean swap the upper case to lower case and vice versa.\n2. By changing vowels, we mean change it to the letter that two position ahead of it in the alphabet, wrapping around if neccesary",
        "Self Reflection": "",
        "Hint": "You can use the ord function to get the Unicode code point of a character and the chr function to convert a code point back to a character, enabling you to shift vowels by adding 2 to their code points and wrapping around using modulo arithmetic."
    },
    "HumanEval/94": {
        "Usage": "Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7",
        "Clarification": "1. By sum, we mean the sum of all digits.",
        "Self Reflection": ""
    },
    "HumanEval/95": {
        "Usage": "Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.",
        "Clarification": "By consistent in case format, we mean the keys are either all lowercase or all uppercase strings",
        "Additional Information": "By consistent, we mean the keys are either all lowercase or all uppercase strings",
        "Self Reflection": "",
        "Hint": "Ensure the function returns False if there are any non-string keys, or if the dictionary is empty, and only returns True if all keys are either all lowercase or all uppercase strings."
    },
    "HumanEval/96": {
        "Usage": "for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]",
        "Clarification": "1. The returned list should in ascending order.\n2. By up to n, we mean less than n.",
        "Self Reflection": ""
    },
    "HumanEval/97": {
        "Usage": "Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.",
        "Self Reflection": ""
    },
    "HumanEval/98": {
        "Usage": "For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0",
        "Self Reflection": ""
    },
    "HumanEval/99": {
        "Usage": "Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15",
        "Clarification": "1. Round away from zero, we mean  for example, '14.5' rounds to 15 and '-14.5' rounds to -15.\n2. The string can always be convert to a number.",
        "Additional Information": "1. The way of conversion is to nearest integer.\n2. Round away from zero in a tie.",
        "Self Reflection": ""
    },
    "HumanEval/100": {
        "Usage": "Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]",
        "Clarification": "1. The first element in the list should be n. The next number is the next odd number if n is odd orthe next even number if n is even.",
        "Self Reflection": ""
    },
    "HumanEval/101": {
        "Usage": "words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]",
        "Clarification": "1. Words are separated by commas or spaces.",
        "Self Reflection": ""
    },
    "HumanEval/102": {
        "Usage": "For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1",
        "Clarification": "1. The range is inclusive.\n2. If no even integer exists in this range, the function returns -1.",
        "Additional Information": ". The range of integer is [x, y] inclusive.\n2. If no even integer exists in this range, the function returns -1.",
        "Self Reflection": ""
    },
    "HumanEval/103": {
        "Usage": "Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"",
        "Clarification": "1. The binary representation should have proper prefix (e.g., 0b).\n2. The range is inclusive from n to m.",
        "Self Reflection": ""
    },
    "HumanEval/104": {
        "Usage": "For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []",
        "Additional Information": "1. The result is sorted in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/105": {
        "Usage": "For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']",
        "Clarification": "1. The list contains only 0 - 9.\n2. The English representation for each number: ('One' for 1, 'Two' for 2, etc.).",
        "Self Reflection": ""
    },
    "HumanEval/106": {
        "Usage": "Example:\n    f(5) == [1, 2, 6, 24, 15]",
        "Clarification": "1. By odd and even, we mean whether the position i is odd and even. For even i, we do factorial(i). Otherwise, we sum over from 1 to i.",
        "Self Reflection": ""
    },
    "HumanEval/107": {
        "Usage": "Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Example 2:\n\n        Input: 12\n        Output: (4, 6)",
        "Clarification": "The range is from 1 to n, inclusive.\n2. By even and odd palindrome, we mean a even/odd number that read the same from forward and backword.\n3. Return a tuple of (even, odd) palindrome",
        "Self Reflection": ""
    },
    "HumanEval/108": {
        "Usage": ">>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3",
        "Clarification": "1. By sum, we mean sum over its digits.\n2. For negative numbers, the first digit is considered negative.",
        "Self Reflection": ""
    },
    "HumanEval/109": {
        "Usage": "For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    move_one_ball([3, 5, 4, 1, 2])==>False\n",
        "Clarification": "1. We want to sort the list in non-decreasing order.\n2. A right shift operation moves each element of the array one position to the right, and the last element moves to the first position.",
        "Self Reflection": ""
    },
    "HumanEval/110": {
        "Usage": "For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"",
        "Clarification": "1. Specifically, we mean if it is possible to exchange elements between two lists (lst1 and lst2) such that after the exchange, all elements in lst1 are even numbers.\n2. We assume the input lists are non-empty.",
        "Additional Information": "1. The return format should be \"Yes\" or \"No\".",
        "Self Reflection": ""
    },
    "HumanEval/111": {
        "Usage": "Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}",
        "Clarification": "1. The dictionary should be the keys are the letters and the values are the counts of each letter's occurrences.\n2. There are only lower case letter.",
        "Additional Information": "1. Return format should be a dict where the keys are the letters and the values are the counts of each letter's occurrences.\n2. The input string is some space-separed characters.",
        "Self Reflection": "",
        "Hint": "Handle edge case for empty strings."
    },
    "HumanEval/112": {
        "Usage": "Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)",
        "Clarification": "1. Specifically, we mean removes all characters in string 's' that match any character in string 'c'",
        "Additional Information": "1. Specifically, we mean removes all characters in string 's' that match any character in string 'c'.\n2. The return format is (resulting string, bool)",
        "Self Reflection": ""
    },
    "HumanEval/113": {
        "Usage": ">>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]",
        "Clarification": "1. every occurrence of the character 'i' in this template string is replaced by the count of odd digits (e.g., the number of odd elements in the str3ng 3 of the input.).",
        "Additional Information": "1. Each output string describes the count of odd digits in the corresponding input string, formatted as 'the number of odd elements in the string i of the input.', where 'i' is replaced by the count of odd digits.",
        "Self Reflection": ""
    },
    "HumanEval/114": {
        "Usage": " Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6",
        "Clarification": "1. Specifically, we mean theminimum among the sum of any contiguous subarray within a given list of integers",
        "Self Reflection": ""
    },
    "HumanEval/115": {
        "Usage": "Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0",
        "Clarification": "1. Each row in the grid represents a well, where '1' indicates a unit of water.\n2. The buck could remove up-to capacity number water from a single puck at once.",
        "Self Reflection": ""
    },
    "HumanEval/116": {
        "Usage": ">>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]",
        "Clarification": "1. Specifically, we mean sort by the number of ones in their binary representation in ascending order.\n2. If there is a tie, sort by value in ascending otder.",
        "Additional Information": "Sort in ascending order and if there is a tie, sort value in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/117": {
        "Usage": "Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]",
        "Self Reflection": ""
    },
    "HumanEval/118": {
        "Usage": "Example:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"",
        "Clarification": "1. By closet, we mean the first from the right.\n2. By surround, we mean there exist consonants right before and after that vowel.\n3. Return empty string if no such vowel.",
        "Self Reflection": ""
    },
    "HumanEval/119": {
        "Usage": "Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'",
        "Clarification": "1. Specifically, we mean concatenate two strings in any order.\n2. by balanced parentheses, we mean all open parentheses '(' matched with corresponding close parentheses ')'\n3. The input string contains only parentheses.",
        "Self Reflection": ""
    },
    "HumanEval/120": {
        "Usage": "Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]",
        "Additional Information": "The top 'k' should be in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/121": {
        "Usage": "Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0",
        "Self Reflection": ""
    },
    "HumanEval/122": {
        "Usage": "Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3",
        "Clarification": "1. More clearly, we mean among the top-k element in the list, we only calculate the number that with at most 2-digits.\n2. We assume 1 <= k <= len(arr)",
        "Self Reflection": ""
    },
    "HumanEval/123": {
        "Usage": "For example:\n    get_odd_collatz(5) returns [1, 5]",
        "Additional Information": "1. The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n2. Return the list in ascending order.",
        "Self Reflection": ""
    },
    "HumanEval/124": {
        "Usage": "for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False",
        "Clarification": "1. A date is considered valid if they appear in a valid range of month range and day range. Note, valid day range varies among month. We assume there are 29 days in Feb.",
        "Additional Information": "1. The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy.",
        "Self Reflection": ""
    },
    "HumanEval/125": {
        "Usage": "Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3",
        "Clarification": "1. The processing priority is specific, It first attempts to split the string by whitespace. If no whitespace is present, it tries to split by commas. If neither whitespace nor commas are present, it counts and returns the number of lowercase letters in the string that have an odd order in the alphabet.",
        "Self Reflection": ""
    },
    "HumanEval/126": {
        "Usage": "Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False",
        "Additional Information": "1. If list has more than 1 duplicate of the same number, return False.",
        "Self Reflection": ""
    },
    "HumanEval/127": {
        "Usage": "samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"",
        "Clarification": "1. By intersection, it means the intersection of two given closed intervals is a prime number. Each interval is represented as a tuple (start, end).\n2. It is assume that for the interval (start, end), start is smaller than or equal to end.",
        "Additional Information": "1. Return format is Yes or No.\n2.  By intersection, it means the intersection of two given closed intervals is a prime number. Each interval is represented as a tuple (start, end).",
        "Self Reflection": ""
    },
    "HumanEval/128": {
        "Usage": "Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None",
        "Clarification": "1. By product of sign, the sign of each integer is represented as 1 for positive numbers, -1 for negative numbers, and 0 for zero.\n2. If the array is empty, return None.",
        "Self Reflection": ""
    },
    "HumanEval/129": {
        "Usage": "Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]",
        "Clarification": "1. By smallest, we mean the sum of value in the path is smallest.\n2. The path don't have to be acyclic.",
        "Self Reflection": ""
    },
    "HumanEval/130": {
        "Usage": "For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8.",
        "Additional Information": "1. the sequence is defined as follows:\n    - tri(1) = 3\n    - tri(n) = 1 + n / 2, if n is even.\n    - tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.",
        "Self Reflection": ""
    },
    "HumanEval/131": {
        "Usage": "For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15",
        "Clarification": "1. By odd number, we mean odd digit.\n2. If no odd digit, return 0.",
        "Self Reflection": ""
    },
    "HumanEval/132": {
        "Usage": "is_nested('[[]]') \u279e True\n    is_nested('[]]]]]]][[[[[]') \u279e False\n    is_nested('[][]') \u279e False\n    is_nested('[]') \u279e False\n    is_nested('[[][]]') \u279e True\n    is_nested('[[]][[') \u279e True",
        "Clarification": "1. A nested subsequence means that at least one pair of brackets is completely enclosed by another pair.",
        "Additional Information": "1. By proper, we mean the brackets are nested properly. A nested subsequence means that at least one pair of brackets is completely enclosed by another pair.",
        "Self Reflection": ""
    },
    "HumanEval/133": {
        "Usage": "Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6",
        "Clarification": "1. By rounded, we mean round up to the nearest integer (ceiling).",
        "Self Reflection": ""
    },
    "HumanEval/134": {
        "Usage": "Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n    check_if_last_char_is_a_letter(\"\") \u279e False",
        "Clarification": "1. By not a word, we mean it is an alphabetical letter that does not form part of a word. A word is defined as a sequence of characters separated by spaces.",
        "Self Reflection": ""
    },
    "HumanEval/135": {
        "Usage": "Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1",
        "Clarification": "1. more clearly, we mean the largest index of elements which is not greater than or equal to the element immediately preceding it.\n2. If no such element, return -1.",
        "Self Reflection": ""
    },
    "HumanEval/136": {
        "Usage": "Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)",
        "Self Reflection": ""
    },
    "HumanEval/137": {
        "Usage": "compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None",
        "Clarification": "1. the floating point might be . or ,\n2. Return none in a tie.",
        "Self Reflection": ""
    },
    "HumanEval/138": {
        "Usage": " Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False",
        "Clarification": "By 4 even parts, we mean whether it can be split into 4 positive even numbers.",
        "Self Reflection": ""
    },
    "HumanEval/139": {
        "Usage": "For example:\n    >>> special_factorial(4)\n    288",
        "Clarification": "1. More clearly, we mean product of the factorials of all integers from n down to 1.",
        "Additional Information": "1. By Brazilian factorial, we mean The Brazilian factorial is defined as the product of the factorials of all integers from n down to 1.\n    Specifically, brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!",
        "Self Reflection": ""
    },
    "HumanEval/140": {
        "Usage": "fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"",
        "Self Reflection": ""
    },
    "HumanEval/141": {
        "Usage": "Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)",
        "Clarification": "Criteria for a valid file name:\n    - Contains no more than three digits.\n    - Contains exactly one dot ('.').\n    - The substring before the dot starts with a letter (a-z, A-Z) and is not empty.\n    - The substring after the dot is one of the following: 'txt', 'exe', 'dll'.",
        "Additional Information": "1. Criteria for a valid file name:\n    - Contains no more than three digits.\n    - Contains exactly one dot ('.').\n    - The substring before the dot starts with a letter (a-z, A-Z) and is not empty.\n    - The substring after the dot is one of the following: 'txt', 'exe', 'dll'.\n2. Return Yes or No.",
        "Self Reflection": ""
    },
    "HumanEval/142": {
        "Usage": "Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126",
        "Clarification": "1. Specifically, if the index is a multiple of 4 but not a multiple of 3, the integer is cubed.",
        "Self Reflection": ""
    },
    "HumanEval/143": {
        "Usage": "Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"",
        "Clarification": "1. The input is given with the format: string representing a sentence separated by whitespace",
        "Self Reflection": ""
    },
    "HumanEval/144": {
        "Usage": "simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False",
        "Clarification": "1. Each fraction is given in the format 'numerator/denominator', where both numerator and denominator are positive integers.",
        "Self Reflection": ""
    },
    "HumanEval/145": {
        "Usage": "For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []",
        "Clarification": "1. By sum, we mean sum of the digits of each number. The negative sign goes with the nearest digit.\n2. If multiple numbers have the same digit sum, they are ordered by their original position in the list.",
        "Self Reflection": ""
    },
    "HumanEval/146": {
        "Usage": "For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2",
        "Self Reflection": ""
    },
    "HumanEval/147": {
        "Usage": "Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).",
        "Clarification": "1. For triple a[i], a[j], a[k] from array a, they should satisfy i < j < k (i.e., no duplication).",
        "Self Reflection": ""
    },
    "HumanEval/148": {
        "Usage": "Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")",
        "Clarification": "1. If either planet1 or planet2 is not a valid planet name, the function returns an empty tuple.\n2. The planet are given by their closedness to the sun, you should sort your answer based on that.",
        "Additional Information": "the closerst to the Sun is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n2. If either planet1 or planet2 is not a valid planet name, the function returns an empty tuple.",
        "Self Reflection": ""
    },
    "HumanEval/149": {
        "Usage": "For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]",
        "Self Reflection": ""
    },
    "HumanEval/150": {
        "Usage": "Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5",
        "Self Reflection": ""
    },
    "HumanEval/151": {
        "Usage": "double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81",
        "Self Reflection": ""
    },
    "HumanEval/152": {
        "Usage": "example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]",
        "Clarification": "1. By difference, we mean absolute difference between game[i] and guess[i] for all position i.\n2. Both lists are assume to be same length.",
        "Self Reflection": ""
    },
    "HumanEval/153": {
        "Usage": " For example, if you are given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n    Example:\n    for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'",
        "Clarification": "1. The strength of an extension is calculated as the difference between the count of uppercase letters (CAP) and the count of lowercase letters (SM).",
        "Additional Information": "1. The strength of an extension is calculated as the difference between the count of uppercase letters (CAP) and the count of lowercase letters (SM).\n2. Return in the format 'ClassName.StrongestExtensionName'.",
        "Self Reflection": ""
    },
    "HumanEval/154": {
        "Usage": "cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True",
        "Clarification": "1. Rotation means cyclically moving the characters of a string around.",
        "Self Reflection": ""
    },
    "HumanEval/155": {
        "Usage": "Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)",
        "Self Reflection": ""
    },
    "HumanEval/156": {
        "Usage": "Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'",
        "Self Reflection": ""
    },
    "HumanEval/157": {
        "Usage": "Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False",
        "Self Reflection": ""
    },
    "HumanEval/158": {
        "Usage": "find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"",
        "Clarification": "Character set mean the number of unique characters.\n2. If there are multiple strings with the same number of unique characters, the function returns the string that appears first in lexicographical order.",
        "Self Reflection": ""
    },
    "HumanEval/159": {
        "Usage": "Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]",
        "Clarification": "1. It returns a list where the first element is the total number of carrots eaten after attempting to eat the needed amount, and the second element is the number of carrots remaining. If the needed carrots exceed the remaining carrots, all available carrots are eaten.",
        "Additional Information": "The function takes the initial number of carrots already eaten, the number of additional carrots needed, and the number of carrots currently available.",
        "Self Reflection": ""
    },
    "HumanEval/160": {
        "Usage": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9",
        "Clarification": "1. operations: ('+', '-', '*', '//', '**')",
        "Self Reflection": ""
    },
    "HumanEval/161": {
        "Usage": "Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"",
        "Clarification": "1. Extreme case means no letters found in the string.",
        "Self Reflection": ""
    },
    "HumanEval/162": {
        "Usage": ">>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'",
        "Self Reflection": ""
    },
    "HumanEval/163": {
        "Usage": "For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]",
        "Clarification": "1. the range is [a, b] inclusive.\n2.Return results in ascending order regardless of whether a is less than or greater than b.\n3. By digits, we mean 1-digit integer.",
        "Self Reflection": ""
    }
}